package ru.spb.devpractices.masterbest.serverside.services.model;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Service;import ru.spb.devpractices.masterbest.serverside.controllers.IntegrationRestController;import ru.spb.devpractices.masterbest.serverside.dto.front.OrderStatusDTO;import ru.spb.devpractices.masterbest.serverside.dto.integration.IntegrationOrderStatusDTO;import ru.spb.devpractices.masterbest.serverside.exceptions.OrderNotFoundException;import ru.spb.devpractices.masterbest.serverside.mappers.OrderUserStatusMapper;import ru.spb.devpractices.masterbest.serverside.model.User;import ru.spb.devpractices.masterbest.serverside.model.order.Order;import ru.spb.devpractices.masterbest.serverside.model.order.OrderStatus;import ru.spb.devpractices.masterbest.serverside.model.order.OrderUserStatus;import ru.spb.devpractices.masterbest.serverside.repo.*;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Set;import java.util.stream.Collectors;@Service@AllArgsConstructor@Slf4jpublic class OrdersService {    private final OrdersRepo ordersRepo;    private final UserService userService;    private final OrderUserStatusRepo orderUserStatusRepo;    private final OrderUserStatusMapper orderUserStatusMapper;    private final IntegrationRestController integrationRestController;    private final OrderTypesRepo orderTypesRepo;    public List<Order> getOrdersByGUID (String guid, Long userId) {        User user = userService.getUserById(userId);        return ordersRepo.findAllByGuidAndUsersContains(guid, user);    }    public Order getOrder (String ikea_number) {        return ordersRepo.findById(ikea_number).orElseThrow(OrderNotFoundException::new);    }    public Order saveOrder(Order order) {        return ordersRepo.save(order);    }    public Map<String, List<Order>> getAllOrdersByUserId (Long userId){        User user = userService.getUserById(userId);        List<Order> orders = ordersRepo.findAllByUsersContains(user);        Map<String, List<Order>> ordersByGuid = orders.stream().collect(Collectors.groupingBy(Order::getGuid));        return ordersByGuid;    }    public ResponseEntity<?> setOrderStatus (OrderStatusDTO dto){        User user = userService.getUserById(Long.valueOf(dto.getUserId()));        List<Order> orders = ordersRepo.findAllByGuidAndUsersContains(dto.getGuid(), user);        List<OrderUserStatus> entitiesList = orderUserStatusMapper.toEntitiesList(dto, orders);        OrderStatus orderStatus = OrderStatus.getStatusByDescription(dto.getStatus());        //статус Прибыл не отправлять в 1С. Он там не нужен и не учитывается.        if (orderStatus!=OrderStatus.Arrived) {            IntegrationOrderStatusDTO integrationDTO = new IntegrationOrderStatusDTO(                    Integer.parseInt(dto.getUserId()),                    orderStatus.name(),                    dto.getGuid(),                    dto.getComment()            );            ResponseEntity<IntegrationOrderStatusDTO> integrationResponce = integrationRestController.setOrderUserStatus(integrationDTO);            if (integrationResponce.getStatusCode() == HttpStatus.OK) {                entitiesList.stream().forEach(entity -> {                    orderUserStatusRepo.save(entity);                });                return ResponseEntity.ok().build();            } else return ResponseEntity.unprocessableEntity().build();        } else {            entitiesList.stream().forEach(entity -> {                orderUserStatusRepo.save(entity);            });            return ResponseEntity.ok().build();        }    }    public Set<OrderStatus> getNextOrderStates(OrderStatus state) {        Set<OrderStatus> retStates = new HashSet<>();        switch (state) {            case Viewed:                retStates.add(OrderStatus.Accepted);                retStates.add(OrderStatus.Rejected);                retStates.add(OrderStatus.CancelledByOperator);                return retStates;            case Accepted:                retStates.add(OrderStatus.Arrived);                return retStates;            case Arrived:                retStates.add(OrderStatus.InWork);                retStates.add(OrderStatus.FalseVisit);                return retStates;            case InWork:                retStates.add(OrderStatus.Suspended);                retStates.add(OrderStatus.Completed);                retStates.add(OrderStatus.NotFinished);                return retStates;            case Suspended:                retStates.add(OrderStatus.Arrived);                return retStates;            default:                log.warn("Для статуса " + state.name() + " нет следующего значения, либо статус не найден") ;                break;        };        return retStates;    }////    public Map<Order, OrderStatus> getAllOrdersByUserId (Long userId, boolean isHistory){//        List<Order> allUserOrders = ordersRepo.findAllByUsers_id(userId);//        Map<Order, OrderStatus> orders = new HashMap<>();//        for (Order order: allUserOrders){//            String ikea_number = order.getIkea_number();//            OrderUserStatus orderUserStatus = orderUserStatusRepo.findAllByUserAndAndOrder(userId, ikea_number);//            if (orderUserStatus.getStatus().isHistoryStatus() == isHistory){//                orders.put(order, orderUserStatus.getStatus());//            }//        }//        return orders;//    }////}