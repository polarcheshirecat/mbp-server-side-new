package ru.spb.devpractices.masterbest.serverside.controllers;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import ru.spb.devpractices.masterbest.serverside.dto.front.OrderDTO;import ru.spb.devpractices.masterbest.serverside.dto.front.OrderStatusDTO;import ru.spb.devpractices.masterbest.serverside.exceptions.UserNotFoundException;import ru.spb.devpractices.masterbest.serverside.mappers.OrderMapper;import ru.spb.devpractices.masterbest.serverside.model.User;import ru.spb.devpractices.masterbest.serverside.model.order.Order;import ru.spb.devpractices.masterbest.serverside.model.order.OrderStatus;import ru.spb.devpractices.masterbest.serverside.services.model.OrdersService;import ru.spb.devpractices.masterbest.serverside.services.model.UserService;import java.lang.reflect.Array;import java.util.*;import java.util.stream.Collectors;@Slf4j@RestController@RequestMapping("/orderservice")@AllArgsConstructorpublic class OrdersController {    private final OrdersService ordersService;    private final UserService userService;    private final OrderMapper orderMapper;//    private final OrderInfoMapper orderInfoMapper;//    private final OrderMapper orderMapper;////   @CrossOrigin   @RequestMapping (value = "/getAllOrders", params = {"userId"})    public ResponseEntity<?> getAllNewOrders (@RequestParam(value = "userId") String userId){        if (!checkIfUserExists(userId)){            return ResponseEntity.notFound().build();        }        Map<String, List<Order>> orders = ordersService.getAllOrdersByUserId(Long.valueOf(userId));        List<OrderDTO> dtoList = new ArrayList<>();        orders.keySet().stream().forEach(guid -> {            List<Order> ordersList = orders.get(guid);            OrderDTO orderDTO = orderMapper.toDTO(ordersList);            dtoList.add(orderDTO);        });       List<OrderDTO> retList = dtoList.stream().sorted(Comparator.comparing(OrderDTO::getDateStart))               .collect(Collectors.toList());       return new ResponseEntity<>(retList, HttpStatus.OK);    }    @CrossOrigin    @RequestMapping(value = "/setOrderStatus",            method = RequestMethod.POST)    public ResponseEntity<?> setOrderStatus(@RequestBody OrderStatusDTO dto){        return ordersService.setOrderStatus(dto);    }    @CrossOrigin    @RequestMapping (value = "/getNextStatuses", params = {"status"})    public ResponseEntity<?> getNextStatuses (@RequestParam(value = "status") String status){        OrderStatus orderStatus = OrderStatus.getStatusByDescription(status);        Set<OrderStatus> nextOrderStates = ordersService.getNextOrderStates(orderStatus);        return new ResponseEntity<>(nextOrderStates, HttpStatus.OK);    }////////    @CrossOrigin//    @RequestMapping (value = "/getOrder", params = {"orderId"})//    public ResponseEntity<?> getOrder (@RequestParam(value = "orderId") String orderId) {//        Order order = null;//        try {//            order = ordersService.getOrder(orderId);//        } catch (OrderNotFoundException ex){//            log.error("Заказ с номером " + orderId +//                    " не найден в БД приложения", ex);//            return ResponseEntity.notFound().build();//        }//        OrderDTO orderDTO = orderMapper.orderToOrderDto(order);//        return new ResponseEntity<>(orderDTO, HttpStatus.OK);//    }////////    private boolean checkIfUserExists (String userId) {        try {           userService.getUserById(Long.valueOf(userId));        } catch (UserNotFoundException ex ){            log.error("Пользователь " + userId +                    " не найден в БД приложения", ex);            return false;        }        return true;    }}